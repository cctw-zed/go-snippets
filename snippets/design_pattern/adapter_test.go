package designpattern

import (
	"testing"
)

/*
结构型模式主要关注如何组合类和对象以实现更大的结构。它们用于简化代码结构，提高代码的可维护性和可扩展性。以下是结构型模式的一种：适配器模式，以及其使用场景和示例。

适配器模式（Adapter Pattern）

适配器模式用于将一个类的接口转换为另一个接口，以使原本不兼容的接口能够一起工作。它主要用于以下场景：

  - 当需要使用现有的类，但其接口与现有代码不兼容时。

  - 当需要将多个不同的类统一为一个统一的接口时。

  - 当需要在不修改原始代码的情况下，使现有代码与第三方库或组件兼容时。

示例：

假设我们正在开发一个电子商务应用程序，该应用程序需要支持多种支付方式（如信用卡、PayPal、Apple Pay 等）。我们可以使用适配器模式来创建一个统一的支付接口，以便在不修改现有代码的情况下，轻松添加新的支付方式。

在这个示例中，我们定义了一个名为 Payment 的目标接口，它表示统一的支付接口。我们还定义了两个适配器：CreditCardAdapter 和 PayPalAdapter，它们将具有不同接口的支付方式适配为 Payment 接口。这样，我们可以使用统一的接口处理不同的支付方式，而无需修改现有代码。

总之，结构型模式关注于如何组合类和对象以实现更大的结构。适配器模式是结构型模式的一种，它用于将不兼容的接口转换为统一的接口，以使原本不兼容的类能够一起工作。这种模式在需要将多个不同的类统一为一个统一的接口或使现有代码与第三方库兼容的场景中非常有用。
*/
func TestAdapter(t *testing.T) {
	// 使用适配器将不同的支付方式适配为统一的接口
	payments := []Payment{
		&CreditCardAdapter{CreditCard: &CreditCard{}},
		&PayPalAdapter{PayPal: &PayPal{}},
	}

	// 使用统一的接口处理支付
	for _, payment := range payments {
		t.Logf(payment.ProcessPayment(100.0))
	}
}
